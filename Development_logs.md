# 22.3.19

已完成舵机旋转扫描

# 22.3.24

用于传输，把数据处理删除，直接传输ascii

# 22.3.27

 计划更改pwm精度

连贯旋转

# 23.3.2

**原f1程序移植到f407**

> 存储器，寄存器
>
> https://developer.aliyun.com/article/934782

> GPIO复用规则不太确定（是可以随意复用吗；不是，需对照datasheet）
>
> https://blog.51cto.com/dlican/3739387

> USART推挽、上拉等应用场景不确定
>
> https://blog.csdn.net/as480133937/article/details/98063549

中断、优先级问题还未考虑，变量是否会冲突等

找到了spl相关手册

# 23.3.3

打算还是用f1

# 23.3.12

完成了单舵机调试

ARR:72,000,000/720/400=250hz

计数器模式2 低极性



完成双舵机

TIM3 

OC2  PB5 （上面的）

OC3  PB0

# 23.3.18

完成了舵机+陀螺仪+雷达联调

发现如下问题：

> 中断里尽量不要有发送操作，可能会程序卡住

> memcpy(&sReg[Roll], usData, 8);//一个usData占2个字节

> 舵机与系统共地   

> led0pwmval=50,led0pwmva2=50;dir1=1,dir2=1;如果非静态变量可能受中断等影响

陀螺仪仅接收角度数据，仍保留时间数据部分代码

雷达数据已经过初筛（去除255）



**OC2  PB5 （上面的）**

**OC3  PB0**

**JY901S(USART3):**
	**USB-TTL                   STM32Core              		JY901s 仅接收角度 俯仰x 横滚y 航向z**
	**VCC          -----           VCC                ----        	 VCC**
	**TX             -----           RX1  (PA10)   
	RX             -----           TX1  (PA9)**
	**GND          -----           GND               ----       	GND**
									   **RX2  (PB11)    ----             TX**
										**TX2  (PB10)    ----             RX**
**LIDAR(USART2):**
	**TX PA2** 
	**RX PA3** 

![image-20230505171045820](.\shanshilog.assets\image-20230505171045820.png)

![image-20230508171606614](.\shanshilog.assets\image-20230508171606614.png)



# 23.4.10

是否考虑合并数据处理部分，生成pcd数据

# 230505

https://www.runoob.com/w3cnote/extern-head-h-different.html

> **总结：**
>
> 对变量而言，如果你想在本源文件(例如文件名A)中使用另一个源文件(例如文件名B)的变量，方法有2种：(1)在A文件中必须用extern声明在B文件中定义的变量(当然是全局变量)；(2)在A文件中添加B文件对应的头文件，当然这个头文件包含B文件中的变量声明，也即在这个头文件中必须用extern声明该变量，否则，该变量又被定义一次。
>
> 对函数而言，如果你想在本源文件(例如文件名A)中使用另一个源文件(例如文件名B)的函数，方法有2种：(1)在A文件中用extern声明在B文件中定义的函数(其实，也可省略extern，只需在A文件中出现B文件定义函数原型即可)；(2)在A文件中添加B文件对应的头文件，当然这个头文件包含B文件中的函数原型，在头文件中函数可以不用加extern。

对上述总结换一种说法：

(a)对于一个文件中调用另一个文件的全局变量，因为全局变量一般定义在原文件.c中，我们不能用#include包含源文件而只能包含头文件，所以常用的方法是用extern int a来声明外部变量。 <u>另外一种方法是可以是**在a.c文件中定义了全局变量int global_num** ，可以在对应的a.h头文件中写extern int global_num ，这样其他源文件可以通过include a.h来声明她是外部变量就可以了。</u>

# 23.5.8

## 方案2

单片：(stm32f103rct6)

**PC2 PC3 PC4 PC5**电机控制：GPIO

**TX PC10  ** **RX PC11**  **VCC GND**电机雷达：UART4、中断

**SCLK b8**  **SDIN b9** **VCC GND**OLED:电机距离实时显示

**RX1  PA10**   **TX1  PA9 ** **VCC GND**串口打印：USART1 

**OC2  PB5** 舵机：PWM 

**RX2  PB11**   **TX2  PB10**  **VCC GND**jy901s:  USART3、中断

**TX PA2**  **RX PA3** **VCC GND**舵机雷达：USART2、中断

（电机雷达）（电机复位/不复位直接读取）（舵机复位）→JY901S→舵机雷达→电机雷达→电机→舵机

→JY901S→舵机雷达→电机雷达→电机→舵机

# 23 5 9

除去测距雷达可以带动

发现JY901不想像想象中那么简单

考先改P版代码尝试建模，查看效果

## jy901s的猜想，不确定是否准确

z轴线性叠加

但是任何情况下是准确的差值

X、Y,在其他轴不动情况下是准确的

# 23 5 10

晃动是否剧烈对于数值会有影响

缓慢移动可以保证一个较准确的值，突然移动则会导致XY角度混乱，z依然一直递增

竖直时的Y与平放是的Y

# 23 5 11

在90度范围内运动是准确的

原以为不能超过正负90°，但是试了下X是可以的超过的，安装方向配置好像没有什么影响，非常需要代码清零校准

> 如何设置参考方向和清零

## 2舵机-JY901s

9%-66%

标定：

42% --0°

19% --123°

# 23.5.12 方案总结

状态：采集并MATLAB 显示

问题：

1. dis数据迟于角度数据一个；MATLAB软件解决

2. 测量范围受限
3. 携带外设较多

遗留任务：

1. PYTHON实时显示未修改

## 方案一猜想

问题：

1. 类似数据错位问题，但经更改代码无果
2. 欧拉角不稳定问题

优点：

1. 范围更广阔，且做好了实时显示

遗留任务：

1. 数据对齐方法
2. jy901s的角度校准

# 23.5.13

测量效果很不理想，直角不明显，平面有波动，且不是点密度的问题

考虑是测量雷达数据读取的问题

方案：

再测量几次查看效果。**阈值范围以设定为1.5cm~5M，误差最小的模式**

读取数据状态，进行matlab筛选。

测量平面是圆弧面，测量直角是弧角是类似的问题吗

多次采样进行平均吧

弧角问题不行就换个传感器试试？

# 23.5.14

**230514box2**   **230514box2**修改了视场角，近距离box效果好非常多 ;但是远距离room效果很差（视场角缩小会影响测量范围？但是只读取有效数据时效果还不错啊） 

**230514box**  **230514room**修改了数据状态判断（只读数据为0的）（这样的话会有数据残影吗）(是会有的) 效果好一点，但是残影问题没法解决，错层是来回扫描导致的

**230514box3 ** **230514box4**回传速率之差会有影响吗，修改角度回传速率为50HZ，距离为30HZ，效果变差了

**230514box5**修改set看看是不是这个原因。也有可能是来回的原因

果然角度数据和距离数据的匹配是主要问题

扫描速率sat也会影响ERR数据错位差值，可能使差值变得不规律

果然数据只差一位是巧合

**230514box6**改低回传速率进行尝试，错位关系变了，应该是未在代码中加读数判断的原因

改回传频率回20HZ,  只传回角度数据，看set是否会影响(会影响)

如果需要设定只读有效数据，需要修改代码逻辑

> # 建档9-2
>
> 1. 不再复位了，直接开始扫描
> 2. 修改代码读取数据逻辑

**230514thing** 5cm左右的物件有波动，不成方，扫描边缘不准确，容易形成扫描阴影

成弧不成方可能是视场角的问题

发现物件部分状态值为11

好像对于变化不敏感

# 23.5.15

更新：修改为不复位直接扫描

> 扫描斜面、扫描直角
>
> 横向扫描、纵向扫描
>
> 就扫描直角

对于非方角的猜想：

1. 在角落里的漫反射——换方向再试试
2. 近距离时细节淹没在误差里；远距离时受测量距离影响（之前的雷达产品效果还不错啊好像）

**230515v-**验证垂直扫描直角，一样无法反映直角，而是弧度

（距离会产生影响吗，比如远近距离）会，近距离会放大这种影响，所以猜想是<u>自身误差淹没细节</u>

（内部是有算法对数据进行处理吗，想请问这个算法会影响传感器对于变化环境的敏感性吗）

（每次断电启动，雷达数据存在漂移）

![image-20230515170518684](.\shanshilog.assets\image-20230515170518684.png)
崔老师，我问了一下这个产品的客服，这个是由于视场角的特性导致的，模块并不是单纯的单点测距，模块具有15~27°可调的FOV视场角，模块会在视场角范围内打出多道激光采取数据，然后内部根据占比来筛选输出占比最高的数据。我尝试横竖切换方向扫描直角，是一样的弧角效果。

**因系统自身原因，考虑换个机械结构！提高精度！！**  **看看丝杠**

# 23.5.16

更新：修改电机步拍为双数

# 23.5.17 - 回归8版，合并log

丝杠需要定制连接片

算法：

首先对采样数据进行滤波：面诊雷达滤波

平面拟合补点算法

去漂移算法

### 代码更新

面阵数据，串口传输非json数据

陀螺仪校准

# 230520

按键测试版



# 230523 方案Ⅲ-XY双滑台

![image-20230505171045820](.\shanshilog.assets\image-20230505171045820.png)

# 230525

### 方案：

定位：
是否复位？
若复位，则可不依靠雷达进行定位
但若复位，需要定位复位位置

假设不考虑复位定位，暂定按键复位
Y轴快速扫描，X轴慢走，S形
         __
|     |   |     |
|     |   |     |   
| __ |   | __| 

45°
67.5°+22.5°
tan22.5° = （0.5*d）/x = 0.414 21 
d =  0.82842 * x 
d = 步进间距

常见 x (100mm-1000mm)
d = 82.8mm


d = 80mm
x = 96.56mm


Y  340mm  80*4
x  300mm  80*3

手动操作测量
自动测量
模式切换

有一个没有接近开关，需要复位功能

调整了矩阵键盘的IO口，从寄存器层面还是没太理解32的底层原理，用chatGPT浪费了很多时间



# 230526

 (1-abs(4-baserow)/8)：角度偏差并不是线性的、对边缘的影响有些大 

![image-20230527110042913](.\shanshilog.assets\image-20230527110042913.png)

(1-(abs(4-baserow)+abs(4-basecol))/16)

并不是很好的效果



是否尝试对**距离进行补偿**？但是怀疑会受面阵整体大小的影响（越远弧越明显）      本质上是距离问题

实现了距离补偿，效果还凑合，看着板板正正

是否考虑对Y、Z也做微小补偿



解决电源问题√ 和 不同距离效果 √

增加电机断电确实可以解决一部分电源问题

距离补偿算法暂且对不同距离状态影响不太大（尝试下远距离）

# 230526

点阵的方向是倒着的！！！！
1   2   3   4   5   6   7   8
57 58 59 60 61 62 63 64（面向测量目标）

修改了电机运行逻辑

采样点稀疏时，像素夹角5.625相对靠谱
采样点密集时，像素间隔似乎小于5.625（较近点的影响被放大）**（再尝试一下）**

巧合事件：调整bias = 50，不同次扫描的像素点恰好Z对齐
bias和dir对于效果的影响
因为目前距离较近，尺寸上影响不大



测试后，28电机的每步较准确
57电机会漏1mm左右，且两轮就到极限了（驱动不起来）

dir = 5.625  Z和X不便测量，Y准确
dir = 2.625 Z和X准确（Z由纵向bias绑定，影响较小，X是深度，也影响不大），Y缩小（受角度影响）

主要问题出在不同次扫描如何对齐

从数据错位理解，相当于bias不准确

目前是像素间距设定4.625 + 边缘角矫正
粗略的模糊成一个平面



找到了圆形矫正的方法，只需要同时乘上行和列的影响因子即可，但是对于对角影响太大，没有起到我想要的对于十字纵横点修正的效果

弧面问题还是存在，不知道什么原因，**<u>明天问问客服吧</u>** 

**<u>问问老师电源供电的问题：</u>**
电源电压会被拉低是什么原因
加大电流后电机发烫和噪声严重
57电机走运行一段时间后驱动不起来

**<u>电机复位问题：</u>**

一个电机有接近开关，另一个没有，目前是按键手动复位





